---
title: eight的起点 - 共识接口
permalink: /docs/zh/common-sense
key: docs-zh-common-sense
---

### 关于世界的认知
继续我们的话题吧。我们前面提到，代码依赖的实质是思维的依赖，思维的改变导致了代码的改变。可是另一方面，在真实的人类社会，尽管变化会传播和扩散，但是影响波动却没有那么剧烈，总会限制在一定范围之内。至少，我调整一个查询目录为何要影响我妈的外卖呢？

这肯定是语言的锅了吧，至少是框架的锅，它们的设计就有问题！如果事情就这么单纯，那为何不设计一种新的语言来摆平这个缺陷呢？仔细一想，换成任何一种语言，似乎也解决不了这个问题：UserInterface依赖着的Search发生变化了，于是它要改变，送外卖的系统又依赖着UserInterface，只能跟着倒霉，然后依赖外卖系统的业务接着倒霉，再然后。。。换成什么语言开发也都那样，只能把送外卖的系统和UserInterface分别服务化，然后UserInterface停机升级时调度一部分资源继续保持外卖接口能正常访问。

但语言不是思维的体现吗？人与人之间明明不是这么做的，他们会灵活很多，为何系统就只能这样呢？是的，如果这一切都是正确的：我们的代码表达着我们的思维、我们的系统经受不住变化、我们的客观世界却并非如此，那么只存在一种可能：我们的思维错了！我们集体对世界的认知出现了偏差。`世界并非如我们思维中那样的运行，它有着我们还未曾看清的边缘`{:.warning}。

人与人之间，人与客观世界之间，虽然也存在千丝万缕的联系，也相互依赖与被依赖，利用与被利用，但并不会因为你发生了改变，我就必须得改变。并不因为我曾依赖过你，我就变得不再是我，而当你消失不见，我就不能存在下去。相反，真实的人类，拥有着自身独立的内核，那些不为外物所动的东西。人与外物的联系，在于不断适应环境的变化而保持自我，环境的改变，影响的是人与世界的联系，而非人本身。只有触碰灵魂的冲击，只有来自内心的诉求，才会促使我们发生改变，但那往往只会发生在世界的某些部分。

非但人是如此，世间万物皆有它的本质。`联系并非固化于事物本质之中，而是伴随着本质的碰撞和相互作用而产生`{:.info}。这样不为外物所动的独立个体们，构造出我们的世界，在不断的碰撞挤压中带来世界的演进，这些难以改变的“本质”们，构造出一道道的防线控制着发生于局部的变化蔓延，让我们的世界保持相对的稳定，不至于产生大的波动。这才是世界本来的模样。
![世界变化](/eight/assets/images/the-world-change.gif){:.rounded width="720px" style="display:block; margin-left:auto; margin-right:auto"}

So，真的是我们的代码写错了，为何要把Search接口写到UserInterface里去呢？

### 我们与世界的联系
到了这里，很多人都快发疯了。到底应该怎么做！你倒是说清楚，UserInterface没有得到Search接口，应该怎么去调用它？！

这个问题，其实应该去问身为人类的自己。当你作为一个User想要去Search的时候，你是怎样的？

人，最初存在于这个世界中时，当他开始去接触这个世界，与这个世界发生联系时，在最初的最初，在他的本质尚未存在、即将诞生的时刻，他处于全能的自我之中。这个世界就是为他设计的，他想要什么，这个世界就应该给他怎样的反馈，他有何愿望，这个世界就应该让他得到满足。此时的他，封闭在自身之中，他不需要理解外物，也不需要依赖他人。他自身的愿望，他自身的动力，构造着他的本质。
![全能自我](/eight/assets/images/heart-of-university.png){:.rounded width="480px" style="display:block; margin-left:auto; margin-right:auto"}

当你是宇宙的中心时，你会需要别人给你一个Search接口吗？世界不是正围绕着你在运行吗？真正重要的难道不是你想要什么吗？这才是属于你“本质”的东西。所以，答案很简单，fellow your heart。只要能达到你的愿望，`想怎么写就怎么写，想怎么调用就怎么调用`{:.error}。只提你对世界的需求，然后由这个世界来负责满足。你提的接口，固化在你的“本质”之中，这是属于你的独一无二的东西，自然不会跟随外物的变化而消亡。

然而伴随着成长，我们认识到世界并非如此，我们毕竟不是万物的主宰。在无数次事与愿违之后，我们理解到若要达成自己的目标，必须要遵从某些约定的规则。于是，我们的身体开始生长出对外的接口，这是我们适应环境，与外界进行连接的器官。没有这些，我们将无法相互依赖与合作。但拥有了这些，不等于我们失去了自我，我们仍然是我们自己，要我们想要的，做我们该做的。

随着成长，我们的行为模式更为成熟。但仔细想想，我们仍然是立足于自己的愿望向世界提出我们的要求，只不过使用着这个世界所认可的接口。我们想要达成怎样的目标，首先考虑的是我们自己的立场，然后制定我们的计划。如果需要外界的协助，到行动的时候，再考虑外界哪里存在合适的接口，然后再去碰运气，如果对方不合适，无非就再换一个。就像是求职，我们会因为某次被拒而原地宕机吗？ 我们盼望什么与能从外界得到什么是两种东西，前者属于自我，后者属于世界。我们不会等待别人给我们什么才去决定我们需要什么，我们不会为别人改变而改变自我，我们也不会因为世界跟我们想象的不太一样就要销毁自我。所以，作为人类的我们，不管处于哪个阶段，决定怎样Search的，从来不是别人。

现在，我们的系统为何跟客观世界运行的不一样也就有了答案。我们的思维在构造系统之时是个什么身份呢？还是那个全能的自我吗？恰恰相反，我们是那个负责事事满足的“世界”。我们需要知道一切模块的愿望，去满足一切它们的要求。我们洞悉着一切，知道所有约定的规则，我们关注着事物的联系，却不幸忽略了它们的本质，把各种外物强塞进它们的内核之中。然后傲慢的告诉它们，这就是你的一部分，你的愿望应当这样实现。于是，我们的系统中的模块，它们的本质受到了侵入。然而世界在不断变化，随之改变的还有规则。很快我们就发现，我们构造的这个系统，所有的模块都是`空心`{:.error}的，它们缺失了稳定的核，经受不住哪怕是轻微改变的冲击。一阵革新的风暴过后，万物寂灭，我们构造的世界清零归位，然后又重启了。

什么时候，我们能够不去扮演“世界”，而是站在“自我”的立场上，去撰写我们的系统呢？

### 世界的基本结构
接下来的问题就有些诡异了：一方面要求我们适应这个世界去服从各种规则；一方面又要求我们维持稳定的本质，不轻易随外物而变动；然而世界太广大，这些规则数之不尽，世界太多变，这些规则在不断改变。这三者相互矛盾，根本不可能同时办到！我们怎能把与不断变动的外界的所有接口，都事先准备好呢？怎能把一切可能用到的过程和方法都在代码中阐述呢？如果没有准备好，当变化来临时，怎能要求我们不去做改变呢？

还是回过头来看看我们自己是如何适应变化的吧：我们生存于世界上，并没有获得对所有人和事物的全知全觉。我们通过成长和学习，习得了为人处世的基本方法和认识改造世界的普遍知识，理解到了这个世界的各种规则。有些很肤浅，它在不断变化，令人目不暇接。有些很本质，它往往简单而朴素，深埋在我们难以看见的地方，但如果我们能够得到领悟，我们就能够用它的尺度衡量万物。我们与人协作，并不需要跟他青梅竹马的一起长大；我们去理解未知事物，也不必回溯到天地创造之初去梳理它的来龙去脉。前者只需要双方都遵循耳熟能详的约定共识，后者只需要度之以运行于万物之上的普遍规律，这就是我们与世界交融的接口。有了这些，我们就能去未曾到过的地方看未曾见过的世界，去遇见未曾经历的人和事，去与他们相互碰撞和协作，当风云变幻之后，我们与他们挥手告别，还能保持着一颗初心的自我，准备着去与下一段旅程相会。

那么，这种共识与规律它是什么？好，回答这个问题之前，我们先看看经过前面的论述，我们已经取得的“共识”吧。我们认识到事物皆是独立的个体，有其相对稳定的内核。它们相互遇见，发生了种种联系。它们中的某些个体正发生着变化，这种变化伴随着联系而传播，遇到稳定的内核而休止。所以，目标明确。我们要研究的普遍规律，正是事物发生联系与响应变化的规律，我们需要达成的共识，正是这种规律本身。

当我们研究事物之间的联系和变化的时候，我们不妨设想一下：事物之间的相互联系，是否也潜藏着某种普遍规律呢？抛开纷纭繁杂的表象，是否存在某些内在的固定公式，能够表达一切可能存在的事物之间发生联系的过程呢？如果答案是肯定的，那么问题不就有了解答？我们能够用一套有限的接口，准备好与无穷的事物互联，我们就能既立足于自我，又使用与他人共鸣的方式向世界表达我们的诉求。这种诉求属于我们自身，与外界模块怎样做的无关，甚至与外界模块此刻是否存在也无关。我们因而获得了自由，又时刻准备着去与世界对话。如果所有的我们均遵循同样的方法，采用同样的接口与世界联系，那么`“共识”`{:.error}也就诞生了。当所有的我们使用“共识”创造出独立“自我”的模块后，当系统需要运行时，当它们需要相互联结时，我们就让它们相聚吧。

那如此自我的模块们是否一定能够相互满足呢？这一切就交给实际运行时再决定吧，或许到时候需要协调，或许到时候需要妥协，或许到时候需要改变...也或许知己就在身边。协调和妥协往往只涉及我们与世界的联系，是我们与环境适配的面孔，是外在的东西。只有当我们真的错了，与各种环境都格格不入，处处碰壁，我们才需要去改变自我，这往往意味着痛苦与代价。但模块的修正与改变，毕竟比人容易很多，不是吗？

如果真能做到上述这些，软件系统将会是一种不可思议的东西，想想看：
- 我们在开发任何一个模块时，只需要关注模块处理问题的领域，也即模块的边界之，然后我们使用“共识”向世界发出诉求，我们也使用“共识”向世界提供服务。这也意味着软件开发被解除了外部依赖，可以随我们的需要而展开。意味着一个庞大的群体可以并行展开工作而较少受到约束。意味着分布于世界各处的人们，能够依靠“共识”来贡献模块，提出诉求，构造系统；
- 模块在开发时是自主的、是独立的，在“自我”的边界内自成一体，只有到运行时才将其连接起来成为整体的系统，才需要去适配与对接。这意味着模块的高内聚与低耦合，意味着模块的环境无关性与可复用，能够不断积累起大厦的砖石，系统的拼装和演进也能适应环境、物竞天择；
- 系统的变化受到模块边界的限制，被限制于某个局部。我们能够轻而易举的更新系统，而不必担心改变的蔓延，这将使调整足够的快、带来的代价足够的小。我们也能轻易的根据系统的变化，判断出稳定的内核与不稳定的联系之间的边界，找出那些真正独立的个体，去封装细微到哪怕几行代码的内核，孤立变化。这将使我们修改足够的快、维护的成本足够的低。

于是，我们就得到了一种高度动态的系统，一种瞬间变化的系统，一种几乎没有耦合的系统，一种并行开发的系统，一种不断积累的系统，一种按需拼装的系统，一种便捷修改的系统，一种曾存在于理想之中却终难得到的系统。

那么，接下来问题的关键是，这样的“共识”可能存在吗？这就涉及到三个问题：客观的、主观的以及主客观结合的。客观上我们需要回答是否存在，主观上我们需要回答是否可知，主客观结合上我们需要回答应当怎样去做。

首先看客观问题，要用一种固定的模板套用万事万物的关联，对于不依人意志为转移的客观世界是否可能？这势必要深入到世界的基本结构。世界的基本结构是什么？这基本上是一个本体论问题了。古往今来的先贤们给出了莫衷一是的解答，各自解释着世界的基本结构。

古希腊的德谟克利特就认为，世界的基本模块是原子，运动使它们发生联系，相互碰撞使它们结合构成万物，万物在永不休止的变化着，而原子却始终保持着自我，最终，原子间分崩离析使事物走向消亡，然后原子继续运动，又开始组成新的事物。
![原子论](/eight/assets/images/atom.png){:.rounded width="360px" style="display:block; margin-left:auto; margin-right:auto"}

所以，在德谟克利特看来，万物的联系只有一个接口——运动。按照他的观点，共识接口应该长成这样：
~~~ java
public interface Thing<P, R> {
	public R move(P... otherThings){}
}
~~~

真是令人感动，谁说没办法用一种统一的方式来表达万物的关联来着？德谟克利特用一个接口就办到了。应该没有什么方法调用能逃脱它的魔掌吧？至少Java是这样。假如我们的模块内部，单纯的只依赖于这个恒古不变的共识，我们几乎可以随心所欲的表达我们对外界的诉求，我们还用在乎怎么才能去Search吗？不过是move(keyword)和move(keyword, dir)的区别罢了，我们不需要依赖于谁给我们一个接口。

而莱布尼兹则认为世界是由无数种单子构成。这些单子各不相同，而且不可分割，外界无法改变其内在，它们只会为内因产生、变化和消亡。世间万物也是由单子构成，但有趣的是单子们并不平等，理性的单子，具有智慧而能思考，是最高级别的单子，低级单子围绕高级单子聚集成物。但即便单子运动与聚合，单子间却根本没有联系，相互也无法认识与感知（呃。。。）。那这个世界又为何能够运作呢？那是因为单子内部被万能的上帝编写好了程序，它们完全按照是设定的模板运动，由一种最高意志统筹，所以看起来才那么和谐。
![单子论](/eight/assets/images/monads.png){:.rounded width="480px" style="display:block; margin-left:auto; margin-right:auto"}

莱布尼兹的模型大概是这样：
~~~ java
public class God {
	private static God theOne = new God();
	private God( {}
	public God getTheOne()	{ return theOne; }
	public Monad manageTheWorld(Monad... monads){}
}

public class Monad {
	void preHarmony(){}
}
~~~
God是个单例，唯一的任务就是管理这些单子们。而单子没有输入输出，只有一个preHarmony方法可供God调用。按理说这个preHarmony应该是个单独开放给God的友元函数，除了God和它自己没谁能动，可Java没这个概念。我们还是忘了莱布尼兹吧，他这个模型要求God集成全部代码，没有实际可操作性。

对于维特根斯坦而言，世界的基本组织单位是事实，这个事实并非指具体的物，而是逻辑上判定的真。而事实的联系是依靠逻辑命题求真而确定的。认识世界的方式在于找到命题的一般形式，这些一般形式他罗列了大概十几个真值函数，他认为这些就是全部表述世界的方式。超出表述范围的不再是有意义的命题，所以必须保持沉默。
![逻辑原子论](/eight/assets/images/Logico-philosophicus.jpg){:.rounded width="480px" style="display:block; margin-left:auto; margin-right:auto"}

维特根斯坦一定是个函数语言的爱好者，它们模型大致就这样：
~~~ java
public interface Fact {}

public interface Function extends Fact {
	boolean wahrheitsfunktion(Fact a, Fact b){}
}

...
// Die allgemeine Form des Satzes
...
~~~
注意Function本身就是可判断真值的Fact，所以其参数可以也是Function。下面注释处定义了一组十几个Die allgemeine Form，没必要罗列我就不写了。全部的接口实现就只有这些。维特根斯坦基本上不怎么需要写模块，他的重点是应该怎么装配这十几个模块来求得一个问题的真值。

现在可以对前面的问题做出结论了：对，我们确实能够用少量简洁的形式表达所有事物之间的联系，方式还不止一种。世界的基本结构怎样，取决于我们如何看待它，我们对它不同的认识方法，产生对它的结构的不同表达方式。但设计得当的任何一种方式，具有完备性，都能够表述我们认识到的世界的全貌。如果这个基本原则得到确立，那我们的系统的结构就大不一样了，事物的依赖关系和关联模式发生了根本性的转变，软件也冲破束缚它的枷锁，一种新的系统形态破茧而出。

就像下面这样，所有的模块之间的静态依赖被解除，它们都只依赖于共识，从依赖之网中解放而获得了自由。它们之间的关系，由内在的依赖变成了外在的联系，而联系由运行时动态赋予，也就可以在运动中随时改变。这是不是才像我们认识的世界？
![新基础架构](/eight/assets/images/new-infrastructure.gif){:.rounded width="720px" style="display:block; margin-left:auto; margin-right:auto"}

好，现在共识接口的存在性已经得到了证明，接下来再看主观问题。我们每个人都是单独的个体，有着不同的内核。即便遵循着相同的共识去法度相同的事物，我们能够得到相似的认知吗？这基本上算是一个认识论的问题。这个星球上生存着几千万代码工作者，它们可能生活在圣荷西，或者生长在北京，又或者漂泊在去往毛里求斯孤岛的木筏上，或是吊挂在亚马逊的原始森林的一棵树上coding。如此不同的人，即便给他们共同的接口，他们就真能产生“共识”，做出可以协调运行的模块吗？

这个问题其实也有不少解答。柏拉图在理想国里，将人对世界的感官体验比喻成洞穴里看到影子。洞穴之内看到的皆是幻影，洞穴之外才是真实。蒙昧的人看到的幻象多种多样，产生了各种错觉，而真实的理想世界则是完美的，只有唯一一个。多变的表象之下蕴含着不变的真理，而普通的人却无法获知。只有通过引导人们形而上学的思考，才能将人带向真知。没错，柏拉图的理想国是唯一的，那里的真知也是绝对的。随着认识的深化，人们的知识也在相互靠近。最终，所有人都将汇合到同一个地点，并在那里见证同样的真知。
![理想国](/eight/assets/images/republic.jpg){:.rounded width="480px" style="display:block; margin-left:auto; margin-right:auto"}

斯宾诺莎则认为世界由实体（自然存在）构成，实体永恒、无限、唯一（注意这里的唯一跟无限并不矛盾，斯宾诺莎的实体基本上等同于类的概念，世界上的类是有无限个，但是完全相同的类却只能是唯一的，理解一下我们是不能定义一个包名类名属性名方法名完全相同的类的，那也毫无意义。）且不可分割。代表物质的广延与代表观念的思想根本就是同一实体（类）的两种属性（这些概念那时候就有了，程序设计本质上是一种形而上学，尤其是面向对象的），一个事物必然对应一个观念。观念的次序和联系与事物的次序和联系是相同的，真观念必定符合它的对象。`人们之所以有各种错误的观念，而无法认识到必然性，是因为他们缺乏理性而被本能所欺骗`{:.success}（这个地方太赞了，推荐我最喜欢的小说之一《人性的枷锁》）。而人的观念按来源分三种：意见、理性和直观。第一种是来自于感官的粗鄙认知，缺乏价值，各种各样的错误认识都来源于此。后两者均是能达到实体本质的真观念。
![实体论](/eight/assets/images/entity-attribute-style.jpg){:.rounded width="480px" style="display:block; margin-left:auto; margin-right:auto"}

按斯宾诺莎的决定论，世界是唯一而必然的，一个事物对应的真观念只有一个，所有的人只要有足够的理性，认识到的真观念必然是唯一的。而人也没有自由意志可言，真正的自由在于认识和服从必然，获得理性的真知。so，按照他的看法，如果你跟亚马逊森林的程序员开发出来的模块对不上，一定是你们俩其中有一个缺乏理性、被本能所奴役而无法产生真观念...或许两个都是。

康德在纯粹理性批判里论述，人们对客观事物的正确认识来源于先验分析判断或先验综合判断。所谓先验也就是与生俱来的，康德认为人生来就被赋予了归类、分析、推理、逻辑等能力。这些能力不是后天习得的，所以自然不会跟随人的成长环境不同而改变。换句话说，你跟荒岛求生的程序员对一个事物进行分析或先验综合得出的结论应当相同，而这个结论就应当是正确且唯一的。那为何人们对事物的观点还会多种多样呢？那是因为人们还在采用后验综合判断，后验判断是习得的，它依靠人的感官经验，偶然而不可靠，所以它不是真理，只能算观点或意见。这个故事告诉我们，开发时多用理性分析，少凭感觉，你的模块就能跟人对的上。
![纯粹理性批判](/eight/assets/images/Kritik-der-reinen-Vernunft.jpg){:.rounded width="480px" style="display:block; margin-left:auto; margin-right:auto"}

以上几位都是理性主义者，他们的结论都很一致：正确的认识（真理）存在且唯一，只要能追求到就一定会是相同的结果，问题的关键在于如何去获得正确的认识。

就我本人而言，我持有经验主义态度。我认为人先天一无所知，也不具备先验的相同认知。人本质上是经验与记忆的总和，无论这些经验与记忆来自环境给予的还是教育习得的。所以不同的人对待相同的事物未必会有相同或类似的认识。但事物本身却是客观的，不随人的意见而改变。所以，对事物正确的认识是普遍而唯一的，放之四海而皆准，这一点我赞同上述各位。然而因为我们认知的出发点只能是感官经验，那必然是不完整的，同时我们又很难拥有纯粹的理性，所以真理又是难以达到的，我们总与它保持或远或近的距离。因此，不同的认识必然有些更正确，有些更错误，或者都有错误，错的各具特色。那么如何才能评判不同认识的高下呢？唯有依靠逻辑与实证。

这么说，不同的人出于经验与记忆的差异，想取得共识几乎不可能咯？其实不然，正因为人是经验的集合体，相同或相似的经验与记忆才承载着相同或相似的认知。换而言之，人所习得的经验越相似，他们对同一事物的认知也越接近，这正是奠定eight的基石。也因此我在前面提问用的是“相似”而不是“相同”，因为毕竟我们的共识只需要相似就能够相互交流与协作。我们在与世界交往，遇上各种各样的人和事，有些相谈甚欢，有些难以沟通。我们总能与具有相似语言、文化、信仰、历史记忆、教育背景、成长环境、一起同甘共苦的人取得更多的共鸣，明白他们所想，知道他们所需，与他们保持默契而无需复杂的相互告知，这就是经验与记忆馈赠予我们的共识。我们并不需要完全相同。
![共识](/eight/assets/images/common-sense.gif){:.rounded width="720px" style="display:block; margin-left:auto; margin-right:auto"}

同样的道理，系统的设计者们作为以coding为生的人，他们在长期的职业生涯中，在面对各种难题的过程中，取得太多共同的经验和记忆。那么他们在面对同一个coding问题，被要求采用同一组接口时，他们思维趋同也将是自然而然的。例如对于一个car，被要求以k-v的形式提供接口。亚马逊的程序员和毛里求斯的伙伴都会很自然想到以下结构：
~~~ javascript
const car = {type:"byd", model:"Han", color:"black"};
~~~
区别在于他们给的attribute可能会稍有不同，key也许命名不同，也许还有些其它细微区别。这些都可以在运行时调整和适配来解决。所以，其实我们应该担忧的是没有经验的门外汉冷不丁甩给我们一个炸弹。那又凭什么判定谁是没有经验的门外汉呢？这些就交给逻辑和实践证明吧（俗称run me the code）。

由此，关于我们是否能够达到共识也得到了肯定的答案。接下来主客观结合的问题。以上所有关于认识的论述，都强调要有正确的认识方法，但到底怎样才算是正确的认知呢？作为开发者，我们如何区分我们面对的问题，哪些是实体的本质，那些是实体之间的联系？所谓的联系，究竟是指什么？应该如何体现？当我们从“自我”出发，取得的共识也仅仅只不过“相似”，我们应该如何做出调整，使这些和而不同的模块融合为一个系统？这些基本上都是方法论的问题了。相比前两个问题，方法论关心的问题更显得具体而实在。

那么原理的论述就到此为止了，我们接下来就来看具体的东西——eight。因为eight本身就是方法论。

### eight的共识接口
在eight的世界观里，这个世界由“物”构成，物有两个部分：代表其特征的属性，代表其运动的行为。由此，eight将共识接口分为两族，分别用于操作属性和行为，面向属性的接口族被称为`资源（Resource）`{:.success}，代表物静的部分；面向行为的接口族被称为`过程（Processor）`{:.success}，代表物动的部分，这两部分发生着错综复杂的`联系`{:.success}。eight认为一切系统的运行皆是在过程在资源上操作的结果，“物”们通过动的过程去彼此影响静的资源，由此构成了系统。

eight的Processor族有三个接口，定义如下：
~~~ java
public interface IProcessor<T,R> {
	public R process(T object);
}

public interface IBiProcessor<K, V, R> {
	public R perform(K first, V second);
}

public interface ITriProcessor<T, K, V, R> {
	public R operate(T first, K second, V third);
}
~~~

Resource族则似于map结构，是一组基础接口的组合与派生。定义如下：
~~~ java
public interface IInputResource<K, V> {
	public V find(K ... paras);
}

public interface IOutputResource<K, V> {
	public <P> P store(V value, K ... paras); 
	public <P> P discard(K ... paras);
	public <P> P empty(K ... paras);
}

public interface IListable<K, V> {
	public Collection<K[]> keys(K ... paras); 
	public Map<K[], V> all(K ... paras); 
}

public interface IResource<K, V> extends IInputResource<K, V>, IOutputResource<K, V> {}

public interface IReadonlyListable<K, V> extends IInputResource<K, V>, IListable<K, V> {

public interface IListableResource<K, V> extends IResource<K, V>, IReadonlyListable<K, V> {}

public interface ITransaction<K, V, U extends IResource<K, V>, R> {
	public R execute(IProcessor<U, R> processor);
}

public interface ITransactionResource<K, V, U extends IResource<K, V>, R> extends IResource<K, V>, ITransaction<K, V, U, R> {}

public interface IListableTransaction<K, V, U extends IResource<K, V>, R> extends IListableResource<K, V>, ITransactionResource<K, V, U, R> {}
~~~

特别的，为了提供更充分的完备性，以应对出现罕见的不适于用“资源”和“过程”模型表达的事物，还提供了一套万能的补充接口（`应注意严格控制使用范围`{:.error}）。补充模型采用名实论世界观，将一切“物”视为一组“名”的“组合”，而每一个“名”又代表一个“资源”或“过程”，构成“物”的局部，可以在该“物”上按名获取这个局部的“资源”或“过程”。这些“资源”或“过程”代表可以对该物进行的操作，而其本身也可能是可扩展的“物”。如图：
![扩展模型](/eight/assets/images/extensible-pattern.png){:.rounded width="480px" style="display:block; margin-left:auto; margin-right:auto"}
~~~ java
public interface IExtendable<M> {
	public Collection<M> methods();
	public <N> N extend(M method);
}

public interface IThing {
	public <L> L present(Class<L> clazz);
}
~~~

最后，还有一个涵盖了所有接口的接口：
~~~ java
public interface IUniversal <K, V, U extends IListableResource<K, V>, T, R> extends IProcessor<T,R>, IBiProcessor<K, V, R>, ITriProcessor<T, K, V, R>, IListableTransaction<K, V, U, R>, IExtendable<T>， IThing {
	public <O> O realObject();
}
~~~

以下是对各接口的说明：

| 接口名 | 说明 | 备注 |
|-
IProcessor|一元过程函数|
IBiProcessor|二元过程函数|
ITriProcessor|三元过程函数|
IInputResource|只读resource|输入参数为数组，表示多级路径
IOutputResource|只写resoruce|
IListable|可列举resource|
IResource|由只读resource和只写resoruce组合构成可读写resource|
IReadonlyListable|由只读resource和可列举resoruce组合构成可列举只读resource|
IListableResource|由可读写resource和可列举resoruce组合构成可列举读写resource|
ITransaction|对于资源存取数据时，如果存在原子性的事务需求，则需要实现事务接口|需要实现R execute(IProcessor<U, R> processor)方法，其方法接受一个IProcessor过程，其过程以U extends IResource<K, V>为输入参数，也即接受一个IResource<K, V>为参数，这个传入的resource是对要被实际运行的resource的封装，其应确保processor过程对其的操作，要么全部成功，要么全部不被执行
ITransactionResource|由可读写resource和事务resource组合构成可读写事务resource|
IListableTransaction|由可列举读写resource和事务resoruce组合构成可列举读写事务resource|
IExtendable|扩展接口IExtendable，该接口可以附加于任何“物”（包括资源和过程），为该物增加任意的可操作的“局部”|
IThing|IThing接口则是另一种扩展方式，它代表一个“物”,该物可以是任意接口（资源或过程）的“综合”|通过present呈现出“物”的不同“方面”
IUniversal|由所有接口组合构成的接口|realObject方法用于获取其代理的“物”
-|

下面是所有这些接口的血缘图谱：
![血缘图谱](/eight/assets/images/bloodline.png){:.rounded width="720px" style="display:block; margin-left:auto; margin-right:auto"}

以上一共15个接口14个方法，这就是eight的全部世界。
